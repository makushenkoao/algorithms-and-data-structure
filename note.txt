Stack
Структура данных стек (stack) представляет собой коллекцию элементов, управляемую по принципу "последний вошел, первый вышел" (LIFO - Last-In, First-Out). Это означает, что элементы добавляются и удаляются только с одного конца стека, называемого вершиной стека (top of the stack). Операции push и pop используются для добавления и удаления элементов в стеке соответственно.
Вот как работают операции push и pop на стеке:
push: Операция push используется для добавления элемента (или нескольких элементов) на вершину стека. Каждый новый элемент, добавленный с помощью операции push, становится вершиной стека.
pop: Операция pop используется для удаления элемента с вершины стека. Элемент, который был добавлен последним (и находится в вершине стека), удаляется. После операции pop, следующий элемент становится вершиной стека.
Хеш-таблица (Hash Table):

Хеш-таблица (или хеш-мап) - это структура данных, которая использует хеширование для хранения и организации данных. Основная идея заключается в том, чтобы быстро находить значение (или значения) по заданному ключу. Работа хеш-таблицы основана на использовании хеш-функции, которая преобразует ключ в индекс (или адрес) внутреннего массива (бакета), где хранятся значения.
Принцип работы хеш-таблицы:
Ключ преобразуется в хеш-код с помощью хеш-функции.
Хеш-код используется для определения индекса во внутреннем массиве (бакете), где хранятся значения.
Если два ключа имеют один и тот же хеш-код (коллизия), то хеш-таблица должна иметь механизм разрешения коллизий, такой как цепочки (linked lists) или открытое адресное хеширование (open addressing).
Когда требуется найти значение по ключу, хеш-таблица использует хеш-код для быстрого доступа к соответствующему бакету и затем выполняет поиск внутри бакета.
Операции, которые можно выполнять с хеш-таблицей:
Вставка (Insertion): Добавление новой пары ключ-значение в хеш-таблицу.
Поиск (Search): Поиск значения по ключу.
Удаление (Deletion): Удаление пары ключ-значение по ключу.
Хеш-таблицы обеспечивают высокую производительность поиска (в среднем O(1) для каждой операции), но требуют хорошей хеш-функции и механизма разрешения коллизий для обеспечения эффективной работы.

Дерево (Tree):
В контексте структур данных, дерево - это иерархическая структура, состоящая из узлов (nodes), связанных ребрами (edges). Каждый узел имеет один родительский узел (за исключением корневого узла) и может иметь одного или нескольких дочерних узлов. Деревья широко используются для организации данных и имеют множество вариаций.
Бинарное дерево (Binary Tree):
Бинарное дерево - это дерево, в котором каждый узел может иметь не более двух дочерних узлов: левого и правого. Бинарные деревья могут быть различных типов, например:
Бинарное дерево поиска (Binary Search Tree, BST): Структура данных, где узлы упорядочены таким образом, что для каждого узла все значения в левом поддереве меньше его значения, а все значения в правом поддереве больше его значения. BST обеспечивает эффективный поиск, вставку и удаление элементов.
Бинарное дерево кучи (Binary Heap): Используется для реализации приоритетных очередей и обладает свойством "кучи", где узлы упорядочены так, что каждый узел имеет значение не больше (для max-heap) или не меньше (для min-heap) значений его дочерних узлов.
Дерево поиска (Tree Search):
Важно отметить, что существуют различные виды деревьев и их применение зависит от конкретных задач. Деревья играют ключевую роль в организации данных в компьютерных науках и программировании.


Алгоритм Дейкстры (Dijkstra's algorithm) - это алгоритм нахождения кратчайших путей во взвешенном ориентированном графе с одним начальным узлом (вершиной). Алгоритм был разработан голландским ученым Эдсгером Дейкстрой в 1956 году и широко используется в сетевых маршрутизаторах, GPS-навигации, и других приложениях, где требуется нахождение кратчайших путей.
Основная идея алгоритма Дейкстры заключается в пошаговом выборе узлов и поиске кратчайшего пути от начальной вершины к остальным. В ходе выполнения алгоритма, для каждой вершины хранятся следующие данные:
Расстояние (distance): Это текущее кратчайшее расстояние от начальной вершины до данной вершины. Изначально расстояние для начальной вершины устанавливается в 0, а для всех остальных вершин - в бесконечность.
Посещен (visited): Флаг, указывающий, была ли вершина посещена или нет.
Предыдущая вершина (previous node): Это информация о предыдущей вершине на кратчайшем пути от начальной вершины до текущей.
Алгоритм Дейкстры выполняется следующим образом:
Инициализация: Устанавливаем начальную вершину и ее расстояние равным 0, а остальные вершины - в бесконечность.
Для текущей вершины (начальной вершины) вычисляем расстояния до всех ее соседей и обновляем их расстояния, если новое расстояние короче.
Помечаем текущую вершину как посещенную и выбираем следующую вершину с наименьшим расстоянием из непосещенных вершин.
Повторяем шаги 2 и 3, пока не посетим все вершины или не достигнем целевой вершины (если алгоритм выполняется до какой-то конкретной цели).
После завершения алгоритма, мы можем восстановить кратчайший путь до любой вершины, используя информацию о предыдущей вершине.
Алгоритм Дейкстры эффективен при работе с неотрицательными весами ребер в графе. Он не гарантирует правильного результата в случае отрицательных весов, так как при использовании алгоритма могут возникнуть "циклы отрицательного веса". Для графов с отрицательными весами обычно используют алгоритмы, такие как алгоритм Беллмана-Форда.
