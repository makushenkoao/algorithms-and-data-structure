// Суть задания: кэшировать (запоминать) результаты вызовов функции factorial, чтобы избежать повторных вычислений для одних и тех же аргументов.

// Название алгоритма: Мемоизация (кэширование).

// Сложность алгоритма:
// Временная сложность: O(1) для доступа к результату из кэша (если уже кэширован), O(N) для вычисления факториала (если не в кэше).
// Пространственная сложность: O(N) для хранения кэшированных результатов, где N - количество уникальных аргументов функции.

// Функция cashFunction принимает другую функцию (fn) и возвращает новую функцию,
// которая кэширует результаты вызовов функции fn.
function cashFunction(fn) {
  const cash = {}; // Объект для хранения кэшированных результатов.
  return function (n) {
    if (cash[n]) {
      console.log("Взято из кеша", cash[n]); // Если результат уже есть в кэше, выводим сообщение и возвращаем его.
      return cash[n];
    }
    let result = fn(n); // Вызываем функцию fn для вычисления результата.
    console.log("Посчитала функция = ", result); // Выводим результат вычисления.
    cash[n] = result; // Сохраняем результат в кэше.
    return result; // Возвращаем результат.
  };
}

// Функция для вычисления факториала числа n.
function factorial(n) {
  let result = 1;
  while (n !== 1) {
    result *= n;
    n -= 1;
  }
  return result;
}

const cashFactorial = cashFunction(factorial); // Создаем кэширующую версию функции factorial.

cashFactorial(5); // Вызываем кэширующую функцию для вычисления факториала 5.
cashFactorial(4); // Вызываем её снова для вычисления факториала 4 (результат взят из кэша).
cashFactorial(3); // Вызываем её снова для вычисления факториала 3 (результат взят из кэша).
cashFactorial(4); // Вызываем снова для факториала 4 (результат взят из кэша).
cashFactorial(5); // Вызываем снова для факториала 5 (результат взят из кэша).
cashFactorial(1); // Вызываем для факториала 1 (результат вычисляется заново, так как он не в кэше).
