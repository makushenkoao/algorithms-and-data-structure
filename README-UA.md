# Алгоритми

### Алгоритм - це набір послідовних дій, які вирішують певну задачу.

### Основні алгоритми:

- Пошук
  - Лінійний пошук
    - Лінійний пошук (також відомий як послідовний пошук) - це один з найпростіших алгоритмів пошуку елемента в колекції даних, такій як масив або список. Цей алгоритм послідовно перевіряє кожен елемент у колекції, доки не буде знайдений шуканий елемент або не буде перевірено кожне значення. Ось основні характеристики лінійного пошуку:
  - Бінарний пошук
    - Бінарний пошук - це ефективний алгоритм пошуку елемента в відсортованому масиві. Алгоритм розділяє масив навпіл і порівнює шуканий елемент з елементом в середині масиву.
- Сортування
  - Сортування бульбашкою
    - Сортування бульбашкою - це простий алгоритм сортування, який порівнює і змінює сусідні елементи, доки масив не буде відсортованим. Незважаючи на те, що він не є найефективнішим алгоритмом сортування, він корисний для навчання та розуміння основних принципів сортування.
  - Сортування вставкою
    - Сортування вставкою - це алгоритм сортування, який спочатку вважає, що перший елемент вже відсортований, а потім послідовно вставляє інші елементи на своє місце.
  - Швидке сортування (Quick Sort)
    - Швидке сортування - це один з найшвидших та ефективних алгоритмів сортування. Воно використовує стратегію "розділяй і володарюй", розділяючи масив на підмасиви та сортуючи їх окремо.
- Рекурсивні алгоритми
  - Факторіал числа
    - Рекурсивний алгоритм для обчислення факторіала числа. Факторіал числа - це добуток всіх додатних цілих чисел від 1 до n.
  - Рекурсивне обчислення чисел Фібоначчі
    - Числа Фібоначчі - це послідовність чисел, де кожне наступне число дорівнює сумі двох попередніх. Рекурсивний алгоритм дозволяє обчислити число Фібоначчі для заданого індексу.
- Алгоритм Дейкстри
  - Пошук найкоротшого шляху в графі
    - Алгоритм Дейкстри використовується для пошуку найкоротших відстаней від початкового вузла до всіх інших вузлів у зваженому графі.
- Обхід дерев
  - Обхід у глибину (Depth-First Traversal)
    - Обхід дерева у глибину - це алгоритм, який відвідує всі вузли дерева по вертикалі, перед тим як переходити вниз. Він часто використовується для пошуку в глибину в графах та обході дерев.
  - Обхід у ширину (Breadth-First Traversal)
    - Обхід дерева у ширину - це алгоритм, який відвідує всі вузли дерева по горизонталі, починаючи з кореневого вузла і послідовно переходячи до вузлів на одному рівні перед переходом до наступного рівня.
- Кешування
  - Просте кешування
    - Просте кешування - це метод збереження результатів виконання функції для прискорення наступних викликів з тими ж аргументами. Це корисна техніка для оптимізації функцій, які можуть бути високоресурсними.

### Основні складності алгоритмів можна розділити на наступні категорії:

- Часова складність (Time Complexity):
  - Часова складність оцінює, скільки часу займає виконання алгоритму в залежності від розміру вхідних даних.
  - Оцінка часової складності зазвичай виражається у "O-нотації" (наприклад, O(1), O(log n), O(n), O(n^2), O(2^n)).
- Просторова складність (Space Complexity):
  - Просторова складність оцінює, скільки пам'яті займає алгоритм в залежності від розміру вхідних даних.
  - Оцінка просторової складності також виражається в "O-нотації".
- Складність пошуку (Search Complexity):
  - Ця складність пов'язана з операціями пошуку елемента у колекції даних.
  - Різні структури даних мають різну складність пошуку. Наприклад, пошук в масиві може мати складність O(n), а в хеш-таблиці - O(1).
- Складність сортування (Sorting Complexity):
  - Оцінює, скільки часу і/або пам'яті потрібно для упорядкування елементів.
  - Популярні алгоритми сортування включають сортування бульбашкою, сортування вибором, швидке сортування, сортування злиттям та інші.
- Складність пам'яті (Memory Complexity):
  - Пов'язана з використанням пам'яті алгоритмом.
  - Деякі алгоритми можуть споживати більше пам'яті, ніж інші, і це може бути критичним у обмежених середовищах.
- Складність паралелізації (Parallelization Complexity):
  - Складність алгоритмів може бути пов'язана з їхньою здатністю до паралелізації, тобто виконання в декількох потоках або процесах одночасно.
- Складність адаптації до змін у даних (Adaptivity Complexity):
  - Ця складність визначає, наскільки легко алгоритм може адаптуватися до змін в даних або змінюються умови.
- Складність підтримки (Maintenance Complexity):
  - Складність, пов'язана з підтримкою, оновленням і відлагодженням коду, що реалізує алгоритм.
- Складність стійкості (Robustness Complexity):
  - Ця складність визначає, наскільки стійким є алгоритм до помилок у даних або некоректного використання.
- Складність паралелізації (Parallelization Complexity):
  - Складність, пов'язана з можливістю та ефективністю паралелізації виконання алгоритму на декількох ядрах процесора.

### Основні складності алгоритмів, які часто зустрічаються:

- O(1), O(log n)
- O(n)
- O(n log n)
- O(n^2)
- O(2^n)
- O(n!)

### Структури даних:

- Масиви (Arrays):
  - Масив представляє собою послідовний набір даних.
  - Він займає конкретну область пам'яті (визначену заздалегідь кількістю елементів).
    - Перевага - ми знаємо позицію кожного елемента і можемо отримати його за постійний час.
    - Недолік - для додавання нового елемента потрібно змінювати масив.
  - Складності:
    - О(1) - отримати елемент
    - О(n) - додати або видалити елемент
    - О(n) - пошук
- Об'єкти (Objects):
  - Об'єкти представляють собою колекції пар ключ-значення.
  - Ключі (або властивості) є рядками і використовуються для доступу до значень.
  - Об'єкти в JavaScript широко використовуються для організації та зберігання даних.
- Зв'язний список (LinkedLists):
  - Зв'язний список складається з вузлів, кожен з яких містить значення і посилання на наступний вузол (або null, якщо це останній вузол).
  - Пошук в зв'язаному списку може вимагати проходження через всі вузли.
  - Складності:
    - О(1) - вставка або видалення в початок або кінець (якщо відомо місце)
    - О(n) - вставка в довільне місце (якщо місце невідоме)
    - О(n) - пошук
- Черга (Queue):
  - Черга - це структура даних, в якій елементи додаються в кінець (enqueue) і видаляються з початку (dequeue).
  - Черги використовуються для управління даними у порядку, в якому вони були додані.
- Стек (Stack):
  - Стек - це структура даних, в якій елементи додаються і видаляються з одного кінця (вершини стека).
  - Операції над стеком включають в себе push (додавання) і pop (видалення) елементів.
  - Стеки використовуються, наприклад, для реалізації оберненої польської нотації.
- Множина (Set):
  - Множина представляє собою колекцію унікальних елементів без дублікатів.
  - Основна відмінність від об'єктів полягає в тому, що ми можемо зберігати не лише рядкові значення в якості ключів, але й об'єкти.
- Мапа (Map):
  - Мапа - це колекція пар ключ-значення, де ключі можуть бути будь-якого типу даних.
  - Основна перевага полягає в тому, що ми можемо додавати і видаляти об'єкти за постійного часу.
- Бінарне дерево (Binary Trees):
  - Бінарне дерево - це ієрархічна структура даних, в якій кожен вузол має не більше двох нащадків.
  - Бінарні дерева часто використовуються для швидкого пошуку і сортування даних.
  - Складності:
    - O(log2n) - вставка або видалення
    - O(log2n) - пошук
- n-арне дерево (N-ary tree):
  - n-арне дерево - це структура даних, в якій кожен вузол може мати кілька нащадків (більше двох).
  - Воно часто використовується для представлення ієрархічних даних, таких як файлові системи.
- Графи (Graphs):
  - Графи - це сукупність вершин і ребер, які з'єднують ці вершини.
  - Графи можуть бути напрямлені (орієнтовані) або ненапрямлені.
  - Графи використовуються для моделювання зв'язків між об'єктами і вирішення різноманітних завдань, таких як пошук шляху та аналіз мереж.
- Хеш-таблиця (Hash Tables):
  - Хеш-таблиця (або хеш-мап) - це структура даних в JavaScript, призначена для ефективного зберігання і пошуку пар "ключ-значення".
  - Основні складові хеш-таблиці включають:
    - Хеш-функція: Це функція, яка приймає ключ (зазвичай рядок) і перетворює його в числове значення, яке називається хешем. Хеш-функція повинна бути швидкою і однозначною, щоб забезпечити швидкий доступ до даних.
    - Масив (ведра): Хеш-таблиця фактично представляє собою масив (або масиви) елементів, які називаються "ведрами" або "buckets". Ці ведра містять фактичні дані.
    - Колізії: Іноді два різних ключі можуть мати однаковий хеш. Це називається колізією. Різні хеш-таблиці можуть використовувати різні методи вирішення колізій, такі як ланцюжки (зберігання колізійних елементів у вигляді списків) або відкрите хешування (спроба знайти інший вільний слот).
    - Операції: Основні операції з хеш-таблицями включають вставку (додавання пари "ключ-значення"), пошук (пошук значення за ключем) і видалення (видалення пари "ключ-значення").

### Деякі з найпоширеніших алгоритмів та структур даних, які використовуються в JavaScript:

- Сортування масивів:
  - Сортування бульбашкою (Bubble Sort): Простий алгоритм сортування, який послідовно порівнює та міняє елементи, доки масив не буде відсортований.
  - Сортування вставками (Insertion Sort): Цей алгоритм послідовно вставляє елементи в відсортовану частину масиву.
  - Сортування вибором (Selection Sort): Алгоритм знаходить мінімальний елемент і переміщує його на початок масиву.
  - Швидке сортування (Quick Sort): Ефективний рекурсивний алгоритм сортування, який розбиває масив на підмасиви та сортує їх.
- Пошук елементів:
  - Лінійний пошук (Linear Search): Послідовний пошук елемента в масиві.
  - Бінарний пошук (Binary Search): Ефективний алгоритм пошуку в відсортованих масивах, який ділить масив пополам та порівнює шуканий елемент з середнім елементом.
- Структури даних:
  - Масиви (Arrays): Впорядковані списки елементів, доступ до яких здійснюється за індексом.
  - Зв'язані списки (Linked Lists): Структури даних, що складаються з вузлів, де кожен вузол містить значення та посилання на наступний вузол.
  - Стеки (Stacks): Структури даних, які працюють за принципом "останній увійшов, перший вийшов" (LIFO).
  - Черги (Queues): Структури даних, які працюють за принципом "перший увійшов, перший вийшов" (FIFO).
  - Хеш-таблиці (Hash Tables): Структури даних, які використовують хеш-функції для швидкого пошуку елементів.
- Рекурсія:
  - Рекурсивні функції можуть викликати самих себе для вирішення задачі. Прикладом може слугувати рекурсивний пошук факторіала числа.
- Сортування та фільтрація масивів:
  - Сортування та фільтрація масивів: JavaScript надає методи, такі як sort(), filter(), map(), reduce(), які дозволяють легко маніпулювати масивами.
- Алгоритми обходу дерев:
  - Якщо вам потрібно працювати з деревоподібними структурами даних, такими як об'єкти або DOM-дерева, то вам знадобляться алгоритми обходу дерев, наприклад, обхід у глибину (DFS) або обхід у ширину (BFS).
- Графи:
  - Для роботи з графами, такими як соціальні мережі або схеми зв'язків, можуть знадобитися алгоритми обходу графів, такі як алгоритм Дейкстри або алгоритм пошуку в глибину (DFS).

### Загальні операції із структурами даних:

![Image 1](images/image_1.png)

### Таблиця складності Big-O:

![Image 2](images/image_2.jpg)

### Приклади:

- [1_linear_search.js](1_linear_search.js)
- [2_binary_search.js](2_binary_search.js)
- [3_selection_sort.js](3_selection_sort.js)
- [4_bubble_sort.js](4_bubble_sort.js)
- [5_quich_sort.js](5_quich_sort.js)
- [6_recursion.js](6_recursion.js)
- [7_poisk_v_shirinu.js](7_poisk_v_shirinu.js)
- [8_matrix_smeznosti.js](8_matrix_smeznosti.js)
- [9_algoritm_dijkstra.js](9_algoritm_dijkstra.js)
- [10_tree_algs.js](10_tree_algs.js)
- [11_cash.js](11_cash.js)
- [12_linked_list.js](12_linked_list.js)
- [13_binary_tree.js](13_binary_tree.js)
- [14_set_map.js](14_set_map.js)
