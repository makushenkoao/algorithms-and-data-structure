# Алгоритмы

### Алгоритм - набор последовательных действий которые решают какую-то задачу

### Основные сложности алгоритмов:

- O(1)
- O(Log2n)
- O(n)
- O(n \* Log2n)
- O(n^2)
- O(n!)

### Основные сложности алгоритмов можно разделить на следующие категории:

- Временная сложность (Time Complexity):
  - Временная сложность оценивает, сколько времени занимает выполнение алгоритма в зависимости от размера входных данных.
  - Оценка временной сложности обычно выражается в "O-нотации" (например, O(1), O(log n), O(n), O(n^2), O(2^n)).
- Пространственная сложность (Space Complexity):
  - Пространственная сложность оценивает, сколько памяти занимает алгоритм в зависимости от размера входных данных.
  - Оценка пространственной сложности также выражается в "O-нотации".
- Сложность поиска (Search Complexity):
  - Эта сложность связана с операциями поиска элемента в коллекции данных.
  - Различные структуры данных имеют разные сложности поиска. Например, поиск в массиве может быть O(n), а в хэш-таблице - O(1).
- Сложность сортировки (Sorting Complexity):
  - Оценивает, сколько времени и/или памяти требуется для упорядочивания элементов.
  - Популярные алгоритмы сортировки включают сортировку пузырьком, сортировку выбором, быструю сортировку, сортировку слиянием и другие.
- Сложность памяти (Memory Complexity):
  - Связана с использованием памяти алгоритмом.
  - Некоторые алгоритмы могут потреблять больше памяти, чем другие, и это может быть критическим в ограниченных средах.
- Сложность параллелизации (Parallelization Complexity):
  - Сложность алгоритмов может быть связана с их способностью к распараллеливанию, то есть к выполнению в нескольких потоках или процессах одновременно.
- Сложность адаптации к изменениям данных (Adaptivity Complexity):
  - Эта сложность определяет, насколько легко алгоритм может адаптироваться к изменениям в данных или изменяющимся условиям.
- Сложность поддержки (Maintenance Complexity):
  - Сложность, связанная с поддержкой, обновлением и отладкой кода, реализующего алгоритм.
- Сложность устойчивости (Robustness Complexity):
  - Эта сложность определяет, насколько устойчив алгоритм к ошибкам в данных или некорректному использованию.
- Сложность параллелизации (Parallelization Complexity):
  - Сложность, связанная с возможностью и эффективностью распараллеливания выполнения алгоритма на нескольких ядрах процессора.

### Структуры:

- Массивы:
  - Массивы представляют собой упорядоченные коллекции элементов одного или разных типов данных.
  - Элементы в массиве доступны по индексу.
  - В JavaScript массивы динамически расширяются, когда добавляются новые элементы.
- Объекты:
  - Объекты представляют собой коллекции пар ключ-значение.
  - Ключи (или свойства) являются строками и используются для доступа к значениям.
  - Объекты в JavaScript широко используются для организации и хранения данных.
- Связный список:
  - Связный список состоит из узлов, каждый из которых содержит значение и ссылку на следующий узел (или null, если это последний узел).
  - Поиск в связанном списке может потребовать прохода через все узлы.
- Очередь:
  - Очередь - это структура данных, где элементы добавляются в конец (enqueue) и удаляются из начала (dequeue).
  - Очереди используются для управления данными в порядке, в котором они были добавлены.
- Стек:
  - Стек - это структура данных, где элементы добавляются и удаляются с одного конца (вершины стека).
  - Операции над стеком включают в себя push (добавление) и pop (удаление) элементов.
  - Стеки используются, например, для реализации обратной польской записи.
- Сет:
  - Сет представляет собой коллекцию уникальных элементов без дубликатов.
  - В JavaScript существует встроенный объект Set для работы с множествами.
- Мэп:
  - Мап - это коллекция пар ключ-значение, где ключи могут быть любого типа данных.
  - В JavaScript существует встроенный объект Map для работы с картами.
- Двоичное дерево:
  - Двоичное дерево - это иерархическая структура данных, в которой каждый узел имеет не более двух потомков.
  - Двоичные деревья часто используются для быстрого поиска и сортировки данных.
- n-арное дерево:
  - n-арное дерево - это структура данных, в которой каждый узел может иметь несколько потомков (больше двух).
  - Он часто используется для представления иерархических данных, таких как файловые системы.
- Графы:
  - Графы представляют собой совокупность вершин и рёбер, связывающих эти вершины.
  - Графы могут быть направленными (ориентированными) или ненаправленными.
  - Графы используются для моделирования связей между объектами и решения разнообразных задач, таких как поиск пути и анализ сетей.
- Хеш-таблица:
  - Хеш-таблица (или хеш-мап) - это структура данных в JavaScript, предназначенная для эффективного хранения и поиска пар "ключ-значение". Вот основные элементы структуры данных хеш-таблицы в JavaScript:
    - Хеш-функция: Это функция, которая принимает ключ (обычно строку) и преобразует его в числовое значение, называемое хешем. Хеш-функция должна быть быстрой и однозначной, чтобы обеспечить быстрый доступ к данным.
    - Массив (buckets): Хеш-таблица фактически представляет собой массив (или массивы) элементов, называемых "ведрами" или "buckets". Эти ведра хранят фактические данные.
    - Коллизии: Иногда два разных ключа могут иметь одинаковый хеш. Это называется коллизией. Разные хеш-таблицы могут использовать разные методы разрешения коллизий, такие как цепочки (хранение коллизионных элементов в виде списков) или открытое хеширование (попытка найти другой свободный слот).
    - Операции: Основные операции с хеш-таблицами включают в себя вставку (добавление пары "ключ-значение"), поиск (поиск значения по ключу) и удаление (удаление пары "ключ-значение")

![Image 1](images/image_1.png)
![Image 2](images/image_2.jpg)
