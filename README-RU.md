# Алгоритмы

### Алгоритм - набор последовательных действий которые решают какую-то задачу

### Основные алгоритмы:

- Поиск
  - Линейный поиск
    - Линейный поиск (также известный как последовательный поиск) - это один из самых простых алгоритмов поиска элемента в коллекции данных, такой как массив или список. Этот алгоритм последовательно проверяет каждый элемент в коллекции до тех пор, пока не будет найден искомый элемент или будет проверено каждое значение. Вот основные характеристики линейного поиска:
  - Бинарный поиск
    - Бинарный поиск - это эффективный алгоритм поиска элемента в отсортированном массиве. Алгоритм разделяет массив пополам и сравнивает искомый элемент с элементом в середине массива.
- Сортировка
  - Сортировка пузырьком
    - Сортировка пузырьком - это простой алгоритм сортировки, который сравнивает и меняет соседние элементы, пока массив не станет отсортированным. Хотя он не является самым эффективным алгоритмом сортировки, он полезен для обучения и понимания основных принципов сортировки.
  - Сортировка вставками
    - Сортировка вставками - это алгоритм сортировки, который сначала считается, что первый элемент отсортирован, а затем последовательно вставляет остальные элементы в правильное место.
  - Быстрая сортировка (Quick Sort)
    - Быстрая сортировка - это один из самых быстрых и эффективных алгоритмов сортировки. Он использует стратегию "разделяй и властвуй", разделяя массив на подмассивы и сортируя их по отдельности.
- Рекурсивные алгоритмы
  - Факториал числа
    - Рекурсивный алгоритм для вычисления факториала числа. Факториал числа - это произведение всех положительных целых чисел от 1 до n.
  - Рекурсивное вычисление чисел Фибоначчи
    - Числа Фибоначчи - это последовательность чисел, где каждое следующее число равно сумме двух предыдущих. Рекурсивный алгоритм позволяет вычислить число Фибоначчи для заданного индекса.
- Алгоритм Дейкстры
  - Поиск кратчайшего пути в графе
    - Алгоритм Дейкстры используется для поиска кратчайшего пути во взвешенном графе. Он начинает с исходного узла и находит кратчайшие расстояния до всех остальных узлов графа.
- Обход деревьев
  - Обход в глубину (Depth-First Traversal)
    - Обход дерева в глубину - это алгоритм, который посещает все узлы дерева по вертикали, прежде чем двигаться вниз. Он часто используется для поиска в глубину в графах и обходе деревьев.
  - Обход в ширину (Breadth-First Traversal)
    - Обход дерева в ширину - это алгоритм, который посещает все узлы дерева по горизонтали, начиная с корневого узла и последовательно переходя к узлам на одном уровне перед переходом к следующему уровню.
- Кеширование
  - Простое кеширование
    - Простое кеширование - это метод сохранения результатов выполнения функции для ускорения последующих вызовов с теми же аргументами. Это полезный прием для оптимизации функций, которые могут быть ресурсоемкими

### Основные сложности алгоритмов можно разделить на следующие категории:

- Временная сложность (Time Complexity):
  - Временная сложность оценивает, сколько времени занимает выполнение алгоритма в зависимости от размера входных данных.
  - Оценка временной сложности обычно выражается в "O-нотации" (например, O(1), O(log n), O(n), O(n^2), O(2^n)).
- Пространственная сложность (Space Complexity):
  - Пространственная сложность оценивает, сколько памяти занимает алгоритм в зависимости от размера входных данных.
  - Оценка пространственной сложности также выражается в "O-нотации".
- Сложность поиска (Search Complexity):
  - Эта сложность связана с операциями поиска элемента в коллекции данных.
  - Различные структуры данных имеют разные сложности поиска. Например, поиск в массиве может быть O(n), а в хэш-таблице - O(1).
- Сложность сортировки (Sorting Complexity):
  - Оценивает, сколько времени и/или памяти требуется для упорядочивания элементов.
  - Популярные алгоритмы сортировки включают сортировку пузырьком, сортировку выбором, быструю сортировку, сортировку слиянием и другие.
- Сложность памяти (Memory Complexity):
  - Связана с использованием памяти алгоритмом.
  - Некоторые алгоритмы могут потреблять больше памяти, чем другие, и это может быть критическим в ограниченных средах.
- Сложность параллелизации (Parallelization Complexity):
  - Сложность алгоритмов может быть связана с их способностью к распараллеливанию, то есть к выполнению в нескольких потоках или процессах одновременно.
- Сложность адаптации к изменениям данных (Adaptivity Complexity):
  - Эта сложность определяет, насколько легко алгоритм может адаптироваться к изменениям в данных или изменяющимся условиям.
- Сложность поддержки (Maintenance Complexity):
  - Сложность, связанная с поддержкой, обновлением и отладкой кода, реализующего алгоритм.
- Сложность устойчивости (Robustness Complexity):
  - Эта сложность определяет, насколько устойчив алгоритм к ошибкам в данных или некорректному использованию.
- Сложность параллелизации (Parallelization Complexity):
  - Сложность, связанная с возможностью и эффективностью распараллеливания выполнения алгоритма на нескольких ядрах процессора.

### Основные сложности алгоритмов, которые чаще всего встречаются:

- O(1), O(log n)
- O(n)
- O(n log n)
- O(n^2)
- O(2^n)
- O(n!)

### Структуры данных:

- Массивы(Arrays):
  - Массив представляет собой последовательный набор каких-то данных
  - он занимает конкретный участок в памяти(изначально определено сколько элементов в нем будет находиться):
    - Плюс - мы знаем позицию каждого элемента и мы можем получить его за константное время
    - Минус - чтобы добавить новый элемент нужно изменять массив
  - Сложности
    - О(1) - получить элемент
    - О(n) - добавить или удалить элемент
    - О(n) - поиск
- Объекты(Objects):
  - Объекты представляют собой коллекции пар ключ-значение.
  - Ключи (или свойства) являются строками и используются для доступа к значениям.
  - Объекты в JavaScript широко используются для организации и хранения данных.
- Связный список(LinkedLists):
  - Связный список состоит из узлов, каждый из которых содержит значение и ссылку на следующий узел (или null, если это последний узел).
  - Поиск в связанном списке может потребовать прохода через все узлы.
  - Сложности
    - О(1) - вставка или удаление в начало или конец если знаем место
    - О(n) - вставка в произвольное место, если не знаем место
    - О(n) - поиск
- Очередь(Queue):
  - Очередь - это структура данных, где элементы добавляются в конец (enqueue) и удаляются из начала (dequeue).
  - Очереди используются для управления данными в порядке, в котором они были добавлены.
- Стек(Stack):
  - Стек - это структура данных, где элементы добавляются и удаляются с одного конца (вершины стека).
  - Операции над стеком включают в себя push (добавление) и pop (удаление) элементов.
  - Стеки используются, например, для реализации обратной польской записи.
- Сет(Set):
  - Сет представляет собой коллекцию уникальных элементов без дубликатов.
  - Основное отличие от объектов в том, что мы можем как ключ хранить не только строковое значение, но и объекты
- Мэп(Map):
  - Мап - это коллекция пар ключ-значение, где ключи могут быть любого типа данных.
  - Основное его преимущество в том, что мы можем за константное время добавлять и извлекать объекты
- Двоичное дерево (Binary Trees):
  - Двоичное дерево - это иерархическая структура данных, в которой каждый узел имеет не более двух потомков.
  - Двоичные деревья часто используются для быстрого поиска и сортировки данных.
  - Сложности:
    - O(log2n) - вставка или удаление
    - O(log2n) - поиск
- n-арное дерево(N-ary tree):
  - n-арное дерево - это структура данных, в которой каждый узел может иметь несколько потомков (больше двух).
  - Он часто используется для представления иерархических данных, таких как файловые системы.
- Графы(Graphs):
  - Графы представляют собой совокупность вершин и рёбер, связывающих эти вершины.
  - Графы могут быть направленными (ориентированными) или ненаправленными.
  - Графы используются для моделирования связей между объектами и решения разнообразных задач, таких как поиск пути и анализ сетей.
- Хеш-таблица(Hash Tables):
  - Хеш-таблица (или хеш-мап) - это структура данных в JavaScript, предназначенная для эффективного хранения и поиска пар "ключ-значение". Вот основные элементы структуры данных хеш-таблицы в JavaScript:
    - Хеш-функция: Это функция, которая принимает ключ (обычно строку) и преобразует его в числовое значение, называемое хешем. Хеш-функция должна быть быстрой и однозначной, чтобы обеспечить быстрый доступ к данным.
    - Массив (buckets): Хеш-таблица фактически представляет собой массив (или массивы) элементов, называемых "ведрами" или "buckets". Эти ведра хранят фактические данные.
    - Коллизии: Иногда два разных ключа могут иметь одинаковый хеш. Это называется коллизией. Разные хеш-таблицы могут использовать разные методы разрешения коллизий, такие как цепочки (хранение коллизионных элементов в виде списков) или открытое хеширование (попытка найти другой свободный слот).
    - Операции: Основные операции с хеш-таблицами включают в себя вставку (добавление пары "ключ-значение"), поиск (поиск значения по ключу) и удаление (удаление пары "ключ-значение")

### Общие операции со структурами данных:

![Image 1](images/image_1.png)

### Таблица сложности Big-O:

![Image 2](images/image_2.jpg)

### Примеры:

- [1_linear_search.js](1_linear_search.js)
- [2_binary_search.js](2_binary_search.js)
- [3_selection_sort.js](3_selection_sort.js)
- [4_bubble_sort.js](4_bubble_sort.js)
- [5_quich_sort.js](5_quich_sort.js)
- [6_recursion.js](6_recursion.js)
- [7_poisk_v_shirinu.js](7_poisk_v_shirinu.js)
- [8_matrix_smeznosti.js](8_matrix_smeznosti.js)
- [9_algoritm_dijkstra.js](9_algoritm_dijkstra.js)
- [10_tree_algs.js](10_tree_algs.js)
- [11_cash.js](11_cash.js)
- [12_linked_list.js](12_linked_list.js)
- [13_binary_tree.js](13_binary_tree.js)
- [14_set_map.js](14_set_map.js)
