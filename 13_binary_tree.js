// Суть задания: реализовать бинарное дерево поиска и продемонстрировать его использование для вставки узлов и вывода всех узлов в порядке обхода.

// Название алгоритма: Бинарное дерево поиска (Binary Search Tree, BST).

// Сложность алгоритма:
// Вставка узла (метод add): В среднем случае, время O(log N), где N - количество узлов в дереве. В худшем случае (например, если узлы добавляются в упорядоченном порядке), время может быть O(N), что приводит к несбалансированному дереву.
// Вывод всех узлов в порядке обхода (метод print): Временная сложность O(N), где N - количество узлов в дереве, так как мы посещаем каждый узел ровно один раз.

// Класс BinaryTree представляет собой бинарное дерево поиска.
class BinaryTree {
  constructor() {
    this.root = null; // Инициализируем корень дерева как null.
  }

  // Метод add(value) добавляет новый узел со значением value в дерево.
  add(value) {
    if (!this.root) {
      this.root = new TreeNode(value); // Если дерево пустое, создаем корневой узел.
    } else {
      let node = this.root;
      let newNode = new TreeNode(value);
      while (node) {
        if (value > node.value) {
          if (!node.right) {
            break;
          }
          node = node.right; // Переходим к правому поддереву.
        } else {
          if (!node.left) {
            break;
          }
          node = node.left; // Переходим к левому поддереву.
        }
      }
      if (value > node.value) {
        node.right = newNode; // Вставляем новый узел в правое поддерево.
      } else {
        node.left = newNode; // Вставляем новый узел в левое поддерево.
      }
    }
  }

  // Метод print(root) выводит значения всех узлов в дереве в порядке обхода.
  print(root = this.root) {
    if (!root) {
      return true;
    }
    console.log(root.value); // Выводим значение текущего узла.
    this.print(root.left); // Рекурсивно вызываем для левого поддерева.
    this.print(root.right); // Рекурсивно вызываем для правого поддерева.
  }
}

// Класс TreeNode представляет узел бинарного дерева поиска.
class TreeNode {
  constructor(value) {
    this.value = value; // Значение узла.
    this.left = null; // Ссылка на левый дочерний узел.
    this.right = null; // Ссылка на правый дочерний узел.
  }
}

const tree = new BinaryTree(); // Создаем экземпляр бинарного дерева.

// Добавляем несколько элементов в дерево.
tree.add(5);
tree.add(2);
tree.add(6);
tree.add(2);
tree.add(1);

tree.print(); // Выводим значения всех узлов в порядке обхода.
